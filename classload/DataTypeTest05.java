/*
        关于java当中的整数型
		byte
		short
		int
		long

*/
public class DataTypeTest05
{
	public static void main(String[]args){
          //100L是long类型字面值
		  //x是long类型变量
		  //不存在类型转换，直接赋值
	    long x = 100L;

		//x变量是long类型，8个字节
		//y变量是int类型，四个字节
		//编译报错，大容量不能直接赋值给小容量
		//int y = x;

		//大容量转换成小容量，需要进行强制类型转换。
		//强制类型转换需要加“强制类型转换符”
		//加上强制类型转换符之后编译通过了，但是运行阶段可能损失精度。
		//所以强制类型转换符谨慎使用，因为损失精度之后可能损失很严重。
  //强转原理：
		//原始数据：00000000 00000000 00000000 00000000 10000000 00000000 00000000 00000000
		//强转之后的数据：10000000 00000000 00000000 00000000
		//将左边的二进制砍掉【所有的数据强转的时候都是这样完成的】
		//10000000 00000000 00000000 00000000目前储存在计算机内部，计算机存储数据都是采用补码的形式储存。
		//所以10000000 00000000 00000000 00000000现在是一个补码形式。
		//将以上的补码转换到原码就是最终的结果。
	   int y = (int)x;
	   System.out.println(y);

	   long k = 2147483648L;
	   int e = (int)k;
	   System.out.println(e);//损失精度非常严重，结果是负数。 【-2147483648】
       
	   //依据目前所学，以下无法编译通过
	   //理由：50是int类型的字面值，b是byte类型的变量
	   //显然是大容量int转换成小容量byte。
	   //大容量转换成小容量是需要添加强制类型转换符的，以下程序没有添加，所以编译报错。
	   //在java语言中，byte字面值不超出范围就可以直接赋值给大容量 不需要强制类型转换
	   byte b = 50;//√

	   byte c = 127;//√
	   //编译报错，128这个int类型的字面值一句超出了byte的取值范围，不能直接赋值给byte类型的变量
	   //byte b1 =128;//×
	   //纠正错误，但是需要使用强制类型转换符
	   //但是一定会损失精度
	   //原始数据：00000000 00000000 00000000 10000000
	   //强转之后：10000000【这是存储在计算机内部的，这是一个补码，他的原码是什么？】
	   byte b1 =(byte)128;//-128
	   System.out.println(b1);

	   /*

	    计算机二进制有三种表示形式：
		原码
		反码
		补码
		计算机在任何情况下底层表示和储存数据的时候都采用了补码形式。
		正数的补码和原码相同。
		负数的补码：负数的绝对值对应的二进制码所有二进制位取反，再加一。

		补码10000000
		原码计算过程：
		      *10000000 - 1 -->01111111
			  *10000000 --> 128
			  *-128
			  */
			  //198的原始数据：00000000 00000000 00000000 11000110
			  //强制类型转换之后：11000110
			  //11000110现在在计算机当中储存，它是一个补码，讲补码装换成原码就是该数字。
			  //11000110 - 1 --> 11000101
			  //00111010【2+8+16+32】 -->58
			  //-58
			byte m =(byte)198;
			System.out.println(m);//-58

			short s =32767;//通过
			short s1 = 32768;//编译报错（不超出取值范围就没事）

			//65535是int类型，四个字节
			//CC是char类型，2个字节
			//按照以前学的知识点来说，以下是错误的。
			char CC =65535//通过
			CC = 65535 //报错

			/*
			 当一个整数字面值没有超过byte，short，chai取值范围，这个字面值可以直接赋值给
			 byte，short，char类型的变量。这种机制sun允许了，目的是为了方便程序员的变成。
			 */
	}
}